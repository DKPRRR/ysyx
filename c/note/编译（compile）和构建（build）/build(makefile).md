## Makefile

### 基本格式

```makefile
<targets> : <prerequisties>
	<commands>
```

##### targets，prerequisties和commands是复数，意思就是可以是多个文件/标签和命令

第一行的意思是targets文件的生成依赖于prerquisties文件，然后怎么生成呢，用第二行的command，这个command就可以是linux 命令行的内容了，一般是gcc,rm,mkdir

或者说targets命令调用了prerequisties，并执行了command命令

#### target：目标文件，可以是任何文件，也可以是一个母标签

##### 文件，通常是objectfile(.o)和执行文件

##### 命令标签

你可以使用如下命令来调用makefile的中的该标签

```
make <target>
```

于是该标签下的的command就会被执行

#### prerequistie：依赖文件，依赖于target文件，可以说是一个子标签

#### command：不同的linux命令行的命令

### 依赖树

https://www.bilibili.com/video/BV1TN4y1375q/?vd_source=7c9c09af30990a4d206a45c3072b7df7 在5:41你可以看到这颗依赖树。

#### 树的构成

基本格式中的targets和prerequisties的对应依赖关系，就像一个个链条一样，把他们链接起来，这些链条构成的往往是棵树，树的根就是你命令要执行的那个target `make <target>`。

你当然可以构建多个树，然后有不同的根标签，就是你的不同执行需求，通过执行不同的`make <target>`命令，达到不同的效果，来满足不同的需求，如`release`、`debug`等

#### 程序的执行

从程序上来说，这是一个递归，当你执行`make  <target>`的时候，因为母标签/文件会先找子标签/文件，再执行他的command，所以根标签被执行，会递归的找到叶子标签，然后执行叶子标签/文件的command，然后再往上回溯执行其他的command，直到树上的所有标签/文件被执行完毕。

#### 文件的更新

如果该母文件比他的所有子文件修改时间（生成时间）都新，那么说明，依赖文件都没有改动过，该文件已经更新到最新，那么就没有不必要重新构建一次。

反之，那就说明该文件是旧的，需要根据更新的源代码文件，重新构建一次。

这样大大节省了，微小改动后的源码重新构建所需的时间。

### 伪目标

通常，程序把一个目标认为是文件的优先级要比认为是标签的优先级要高。

#### 需求

如果我们只希望一个target是一个标签（方便使用命令调用的根标签），而不是一个文件，在我们`make <target>`的时候，如果真的有个文件叫这个标签的名，就会出现歧义，就会认为这是个文件，然后根据文件的更新原则，就全乱套了，你懂的。

所以我们需要有个特殊的标记来指出这不是个文件而是个标签。

```
.PHONY : <targets>
```

phony的意思是假的，后面声明的目标全都是标签，而不是文件（假的）。