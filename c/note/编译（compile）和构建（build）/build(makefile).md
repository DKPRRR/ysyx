# Makefile

## 基本格式

```
<目标targets> : <依赖prerequisties>
	<commands>
```

#### targets，prerequisties和commands是复数，意思就是可以是多个文件/标签和命令

第一行的意思是targets文件的生成依赖于prerquisties文件，然后怎么生成呢，用第二行的command，这个command就可以是linux 命令行的内容了，一般是gcc,rm,mkdir

或者说targets命令调用了prerequisties，并执行了command命令

### target：目标文件，可以是任何文件，也可以是一个母标签

#### 文件，通常是objectfile(.o)和执行文件

#### 命令标签

你可以使用如下命令来调用makefile的中的该标签

```
make <target>
```

于是该标签下的的command就会被执行

### prerequistie：依赖文件，依赖于target文件，可以说是一个子标签

### command：不同的linux命令行的命令

## 依赖树

https://www.bilibili.com/video/BV1TN4y1375q/?vd_source=7c9c09af30990a4d206a45c3072b7df7 在5:41你可以看到这颗依赖树。

### 树的构成

基本格式中的targets和prerequisties的对应依赖关系，就像一个个链条一样，把他们链接起来，这些链条构成的往往是棵树，树的根就是你命令要执行的那个target `make <target>`。

你当然可以构建多个树，然后有不同的根标签，就是你的不同执行需求，通过执行不同的`make <target>`命令，达到不同的效果，来满足不同的需求，如`release`、`debug`等

### 程序的执行

从程序上来说，这是一个递归，当你执行`make  <target>`的时候，因为母标签/文件会先找子标签/文件，再执行他的command，所以根标签被执行，会递归的找到叶子标签，然后执行叶子标签/文件的command，然后再往上回溯执行其他的command，直到树上的所有标签/文件被执行完毕。

### 文件的更新

如果该母文件比他的所有子文件修改时间（生成时间）都新，那么说明，依赖文件都没有改动过，该文件已经更新到最新，那么就没有不必要重新构建一次。

反之，那就说明该文件是旧的，需要根据更新的源代码文件，重新构建一次。

这样大大节省了，微小改动后的源码重新构建所需的时间。

## 伪目标

通常，程序把一个目标认为是文件的优先级要比认为是标签的优先级要高。

### 需求

如果我们只希望一个target是一个标签（方便使用命令调用的根标签），而不是一个文件，在我们`make <target>`的时候，如果真的有个文件叫这个标签的名，就会出现歧义，就会认为这是个文件，然后根据文件的更新原则，就全乱套了，你懂的。

### 定义

所以我们需要有个特殊的标记来指出这不是个文件而是个标签。

```
.PHONY : <targets>
```

phony的意思是假的，后面声明的目标全都是标签，而不是文件（假的）。

## 变量

**所有的变量都是字符串**

变量在声明时需要赋初值，在使用时需要添加$()或者${}，表示引用这个变量，来和字符串作区分（字符串反而不需要任何符号引用）

同时，在command行，有一些自动变量，这是自动生成的，无需用户定义。

**`$@`**：目标名。

**`$<`**：第一个依赖的名称。

**`$^`**：所有依赖文件的名称列表（不包含重复项）。

**`$?`**：比目标文件更新的依赖文件的名称列表。

**`$*`**：匹配模式中的通配符部分（不包含后缀）。

## 赋值操作符（存疑）

`=` 是 Makefile 中最常见的赋值操作符，它进行**递归展开（Lazy Assignment）**。这意味着变量的值在**引用时**才会被求值，而不是在赋值时立即求值。对于依赖于其他变量或函数的变量定义，`=` 非常有用。

`:=` 进行**简单展开（Immediate Assignment）**。这意味着变量的值在**赋值时**就被立即求值并展开，而不是在引用时求值。使用 `:=` 可以避免不必要的递归求值，通常用于想在定义时立即确定变量值的情况。

`?=` 是**条件赋值**操作符，只有当变量尚未定义时才进行赋值。如果变量已经定义，它将保持原来的值。这对于定义默认值很有用。

`+=` 是**追加赋值**操作符，表示将一个新值附加到变量的现有值之后。它可以与 `=` 或 `:=` 结合使用。

`::=` 是 GNU Make 的一种不常见的赋值操作符，它用于**静态模式规则展开**。它与 `:=` 的工作方式类似，区别在于 `::=` 是用在静态模式规则中的。它常常用于在静态模式规则中对变量进行赋值或展开，以便避免递归求值。普通情况下用不到这个操作符，只有在静态模式规则中使用时才有效。

## %

## 注释和续行

**注释符号**：使用 `#` 来标记注释，从 `#` 开始到行末的所有内容都是注释。

```makefile
# 这是一个注释
CC = gcc  # 设置编译器为 gcc
```

**续行符号**：使用反斜杠 `\` 将长命令或变量定义分成多行书写，以增强 Makefile 的可读性和可维护性。

```makefile
all:
    echo Compiling... \
    && gcc -o myprog main.c \
    && echo Done!
```



## 函数

函数和c语言一样，有参数有返回值。所以通常**用在赋值符号的右边**。而且**函数可以嵌套函数**。

除了shell，所有函数的用法都可以归为这样的范例

```
<被赋值的变量> := $(<函数名> <参数1> <参数2> ...)
```

### shell

`shell` 函数用于在 Makefile 中调用 shell 命令，并将其输出作为 Makefile 中的变量值。

```
<被赋值的变量> := $(shell <command>)
```

`<command>` 是你要执行的 shell 命令。

该函数的输出是命令的标准输出（stdout）。

### subst

`subst` 函数用于字符串替换，将字符串中的某个子字符串替换为另一个字符串。

```
$(subst from,to,text)
```

`from`：要替换的子字符串。

`to`：替换为的字符串。

`text`：要处理的文本。

### patsubst

`patsubst` 是基于模式匹配的字符串替换函数，常用于文件名的批量处理。它可以将符合某种模式的部分替换为其他内容。

```
$(patsubst pattern,replacement,text)
```

`pattern`：要匹配的模式，通常包含通配符 `%`。

`replacement`：要替换为的字符串，`%` 会匹配模式中的通配符。

`text`：要处理的文本。

### foreach

`foreach` 函数用于对列表中的每个元素执行相同的操作，类似于编程语言中的循环。

```
$(foreach var,list,operation)
```

`var`：循环变量名。

`list`：要迭代的列表。

`operation`：对每个元素执行的操作。

### dir

`dir` 函数返回文件路径的目录部分。它从输入的文件路径中提取目录部分，保留斜杠。

```
$(dir names)
```

`names`：要处理的文件路径列表。

### notdir

`notdir` 函数与 `dir` 函数相反，它返回文件名部分，去掉路径。

```
$(notdir names)
```

`names`：要处理的文件路径列表。

### filter

`filter` 函数用于筛选符合某个模式的字符串，返回匹配的部分。

```
$(filter pattern,text)
```

`pattern`：用于筛选的模式，可以包含通配符。

`text`：要处理的文本。

### basename

`basename` 函数用于去除文件名中的扩展名，返回文件名的主干部分。

```
$(basename names)
```

`names`：要处理的文件名列表。