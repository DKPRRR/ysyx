# Makefile

make主要用于处理c/c++的编译工作，但是所有的编译器/解释器只要能在命令行终端运行的编程语言都可以处理。make也不只能用来处理编程语言，所有基于一些文件的改变（依赖）去更新另一些文件（目标）的工作都可以做。

一个Makefile文件通常由五种类型的内容组成：规则、变量定义、指令和注释

https://www.gnu.org/software/make/manual/make.html

## 规则

### 规则的基本组成

```
<目标targets> : <依赖prerequisties>
	<方法commands>
```

或者可以在一行

```
<目标targets> : <依赖prerequisties> ; <方法commands>
```

这样一个小单元就叫规则。makefile就是由一个个规则组成的。

**targets，prerequisties和commands是复数，意思就是可以是多个文件/标签和命令**

第一行的意思是targets文件的生成依赖于prerquisties文件，然后怎么生成呢，用第二行的command，这个command就可以是linux 命令行的内容了，一般是gcc,rm,mkdir

或者说targets命令调用了prerequisties，并执行了command命令

### 显式规则

一个规则，目标、依赖、方法齐全就是显示规则。

### 隐式规则

如果一个规则，缺少目标、依赖、方法中的任何一个，都是隐式规则，根据文件自动推导如何从依赖生成或更新目标文件。不建议这么做

在此处也不探究。

## 目标target

目标文件，可以是任何文件

#### 文件，通常是objectfile(.o)和执行文件

#### 命令标签

你可以使用如下命令来调用makefile的中的目标，生成该目标。

```
make <target>
```

于是该目标下的依赖树的就会被一一执行。

## 依赖prerequistie

依赖于target文件，可以说是一个子标签。

### **普通依赖**

前面说过的这种形式都是普通依赖。直接列在目标后面。普通依赖有两个特点：

1. 如果这一依赖是由其他规则生成的文件，那么执行到这一目标前会先执行生成依赖的那一规则 
2. 如果任何一个依赖文件修改时间比目标晚，那么就重新生成目标文件

### **order-only依赖**

依赖文件不存在时，会执行对应的方法生成，但依赖文件更新并不会导致目标文件的更新

如果目标文件已存在，order-only依赖中的文件即使修改时间比目标文件晚，目标文件也不会更新。

定义方法如下：

```makefile
targets : <normal-prerequisites> | <order-only-prerequisites>
```

normal-prerequisites部分可以为空

## 方法command

不同的linux命令行的命令

如果另起一行，所有command都需要一个tab的缩进

### shell指令的回显

默认该语句会被回显（执行会先打印指令，再执行），使用@符号，可以取消回显

```
	echo 321  #
	@echo 321 #隐藏
```

默认每条语句的执行环境都是一个独立的进程，就是相当于每条指令执行都会单独开一个终端，他们之间的环境变量独立。

可以使用`.ONESHELL：`作为一个特殊的规则放到makefile头部，来指定这些语句都在个shell进程内运行，以确保环境变量的连贯性。

```
.ONESHELL:
```

这个特殊规则没有依赖和方法。

## 一些特殊的规则

这些规则的存在就像shell中的环境变量一样，他们也是makefile中的环境变量，设定一些基础的属性。

这些规则的目标头部的.表明了他们的特殊性。

### 同一进程.ONESHELL

```
.ONESHELL:
```

这个规则没有依赖和方法，他的存在是为了使makefile中的shell都在一个进程内执行。

### 关闭回显.SILENT

这个规则可以用来替代@来让shell命令关闭回显

```
.SILENT:clean main.o <其他需要关闭回显的规则的目标>
```

这个指定的目标的规则下的所有方法都会关闭回显。

该规则没有方法。

### 伪目标.PHONY

如果我们希望一个目标只是方便make调用的参数，而不是一个目标文件，那么这个叫伪目标。

在我们`make <target>`的时候，如果真的有个文件叫这个标签的名，就会出现歧义，就会认为这是个目标文件，然后根据文件的更新原则，就不会执行，因为他太新了，你懂的。

**通常，makefile会默认一个目标是目标文件，而不是伪目标，**

#### 定义

所以我们需要有个特殊的标记来指出这不是个目标文件，不需要被生成，而是个伪目标。

```
.PHONY : <targets>
```

phony的意思是假的，后面声明的目标全都是伪目标，而不是目标文件。

该规则没有方法

## 依赖树

https://www.bilibili.com/video/BV1TN4y1375q/?vd_source=7c9c09af30990a4d206a45c3072b7df7 在5:41你可以看到这颗依赖树。

### 树的构成

基本格式中的targets和prerequisties的对应依赖关系，就像一个个链条一样，把他们链接起来，这些链条构成的往往是棵树，树的根就是你命令要执行的那个target `make <target>`。

你当然可以构建多个树，然后有不同的根标签，就是你的不同执行需求，通过执行不同的`make <target>`命令，达到不同的效果，来满足不同的需求，如`release`、`debug`等

### 程序的执行

从程序上来说，这是一个递归，当你执行`make  <target>`的时候，因为母标签/文件会先找子标签/文件，再执行他的command，所以根标签被执行，会递归的找到叶子标签，然后执行叶子标签/文件的command，然后再往上回溯执行其他的command，直到树上的所有标签/文件被执行完毕。

### 文件的更新

如果该母文件比他的所有子文件修改时间（生成时间）都新，那么说明，依赖文件都没有改动过，该文件已经更新到最新，那么就没有不必要重新构建一次。

反之，那就说明该文件是旧的，需要根据更新的源代码文件，重新构建一次。

这样大大节省了，微小改动后的源码重新构建所需的时间。

## Makefile读取过程

GNU make分两个阶段来执行Makefile，第一阶段(读取阶段)：

- 读取Makefile文件的所有内容

- 根据Makefile的内容在程序内建立起变量

- 在程序内构建起显式规则、隐式规则

- 建立目标和依赖之间的依赖图

第二阶段(目标更新阶段)：

- 用第一阶段构建起来的数据确定哪个目标需要更新然后执行对应的更新方法

变量和函数的展开如果发生在第一阶段，就称作**立即展开**，否则称为**延迟展开**。立即展开的变量或函数在第一个阶段，也就是Makefile被读取解析的时候就进行展开。延迟展开的变量或函数将会到用到的时候才会进行展开，有以下两种情况：

+ 在一个立即展开的表达式中用到

+ 在第二个阶段中用到

**显式规则中，目标和依赖部分都是立即展开，在更新方法中延迟展开**



## 变量

**所有的变量都是字符串**，区分大小写，名称中不能有: # =

变量在声明时需要赋初值，在使用时需要添加$()或者${}，表示引用这个变量，来和字符串作区分（字符串反而不需要任何符号引用）

同时，在command行，有一些自动变量，这是自动生成的，无需用户定义。

**`$@`**：目标名。

**`$<`**：第一个依赖的名称。

**`$^`**：所有依赖文件的名称列表（不包含重复项）。

**`$?`**：比目标文件更新的依赖文件的名称列表。

**`$*`**：匹配模式中的通配符部分（不包含后缀）。

## 赋值操作符（存疑）

`=` 是 Makefile 中最常见的赋值操作符，它进行**递归展开（Lazy Assignment）**。这意味着变量的值在**引用时**才会被求值，而不是在赋值时立即求值。对于依赖于其他变量或函数的变量定义，`=` 非常有用。

`:=` 进行**简单展开（Immediate Assignment）**。这意味着变量的值在**赋值时**就被立即求值并展开，而不是在引用时求值。使用 `:=` 可以避免不必要的递归求值，通常用于想在定义时立即确定变量值的情况。

`?=` 是**条件赋值**操作符，只有当变量尚未定义时才进行赋值。如果变量已经定义，它将保持原来的值。这对于定义默认值很有用。

`+=` 是**追加赋值**操作符，表示将一个新值附加到变量的现有值之后。它可以与 `=` 或 `:=` 结合使用。

`::=` 是 GNU Make 的一种不常见的赋值操作符，它用于**静态模式规则展开**。它与 `:=` 的工作方式类似，区别在于 `::=` 是用在静态模式规则中的。它常常用于在静态模式规则中对变量进行赋值或展开，以便避免递归求值。普通情况下用不到这个操作符，只有在静态模式规则中使用时才有效。

## %

## 注释和续行

**注释符号**：使用 `#` 来标记注释，从 `#` 开始到行末的所有内容都是注释。

```makefile
# 这是一个注释
CC = gcc  # 设置编译器为 gcc
```

**续行符号**：使用反斜杠 `\` 将长命令或变量定义分成多行书写，以增强 Makefile 的可读性和可维护性。

```makefile
all:
    echo Compiling... \
    && gcc -o myprog main.c \
    && echo Done!
```



## 函数

函数和c语言一样，有参数有返回值。所以通常**用在赋值符号的右边**。而且**函数可以嵌套函数**。

除了shell，所有函数的用法都可以归为这样的范例

```
<被赋值的变量> := $(<函数名> <参数1> <参数2> ...)
```

### shell

`shell` 函数用于在 Makefile 中调用 shell 命令，并将其输出作为 Makefile 中的变量值。

```
<被赋值的变量> := $(shell <command>)
```

`<command>` 是你要执行的 shell 命令。

该函数的输出是命令的标准输出（stdout）。

### subst

`subst` 函数用于字符串替换，将字符串中的某个子字符串替换为另一个字符串。

```
$(subst from,to,text)
```

`from`：要替换的子字符串。

`to`：替换为的字符串。

`text`：要处理的文本。

### patsubst

`patsubst` 是基于模式匹配的字符串替换函数，常用于文件名的批量处理。它可以将符合某种模式的部分替换为其他内容。

```
$(patsubst pattern,replacement,text)
```

`pattern`：要匹配的模式，通常包含通配符 `%`。

`replacement`：要替换为的字符串，`%` 会匹配模式中的通配符。

`text`：要处理的文本。

### foreach

`foreach` 函数用于对列表中的每个元素执行相同的操作，类似于编程语言中的循环。

```
$(foreach var,list,operation)
```

`var`：循环变量名。

`list`：要迭代的列表。

`operation`：对每个元素执行的操作。

### dir

`dir` 函数返回文件路径的目录部分。它从输入的文件路径中提取目录部分，保留斜杠。

```
$(dir names)
```

`names`：要处理的文件路径列表。

### notdir

`notdir` 函数与 `dir` 函数相反，它返回文件名部分，去掉路径。

```
$(notdir names)
```

`names`：要处理的文件路径列表。

### filter

`filter` 函数用于筛选符合某个模式的字符串，返回匹配的部分。

```
$(filter pattern,text)
```

`pattern`：用于筛选的模式，可以包含通配符。

`text`：要处理的文本。

### basename

`basename` 函数用于去除文件名中的扩展名，返回文件名的主干部分。

```
$(basename names)
```

`names`：要处理的文件名列表。