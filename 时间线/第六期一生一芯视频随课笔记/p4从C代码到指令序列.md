# 编译

## 预处理

### 头文件是如何找到的？

man gcc并搜索-I选项可得知头文件搜索的顺序

<>将会在默认的给出的路径进行搜索，这些路径你可以在man中找到

“”将会在当前目录进行搜索



### 预处理的其他工作

去掉注释

连接因断行符（行尾的\）而拆分的字符串/语句

处理条件编译#ifdef#else#endif

字符串化#  ？？？

标识符连接##  ？？？



## 编译

词法分析->语法分析->语义分析->中间代码生成->优化->目标代码生成

### 词法分析

识别并记录源文件中每一个token

token：标识符，关键字，常数，字符串，运算符，大括号，分号

还记录了token的位置（文件名：行号：列号）

### 语法分析

按C语言的语法将识别出来的token组织成树状结构

- AST（初项语法树），可以反映出源程序的层次结构
- 报告语法错误，例如漏了分号

### 语义分析

按照c语言的语义确定ast中每个表达式的类型

- 相容的类型将根据c语言标准规范进行类型转换

  算术类型转换

- 报告语义错误

  未定义的引用

  运算符的操作数类型不匹配

  函数调用参数的类型和数量不匹配

### 静态程序分析

不运行程序的情况下对其进行分析

- 本质就是分析AST中的信息 

  语法错误，代码风格和规范，潜在的软件缺陷，安全漏洞，性能问题

### 中间代码生成

中间代码（IR），编译器定义的，面向编译场景的指令集

将c语言状态机翻译成IR状态机

### 为什么不直接翻译到指令集ISA？

基于抽象曾进行**优化**很容易

可以支持多种源语言和目标语言（指令集）

**clang使用的中间代码叫`LLVM IR`**

**gcc的叫`GIMPLE`**

### 优化

如果两个状态机在某种意义上相同,就可以用简单的替代复杂的

简单=状态少（变量少），激励事件少（语句少）

最复杂=严格按照语句的语义来翻译（严格的状态转移）

相同=程序的可观测行为（C99）的一致性

- 对volatile修饰变量的访问需要严格执行
- 输入输出需要与严格执行一致

### 目标代码生成

将IR状态机翻译成指令集ISA状态机

同时进行目标ISA相关的优化

- 把经常使用的变量放到寄存器，不太常用的变量放到内存
- 选择指令数量较少的指令序列
- ...

## 汇编

将ISA翻译成二进制机器码

## 链接

合并多个目标文件，生成可执行文件

##  执行

把可执行文件加载到内存，跳转到2程序，执行编译出的指令序列

### 谁来加载？

运行时环境（宿主操作系统/QEMU）

## C语言标准对行为的定义

没有明确定义各类型的长度，只定义了类型的最小范围（单位：字节）

而且并没有定义一个字节多少比特

### 未指定行为

C标准提供了多种行为可选，具体实现需要选择

例：函数调用时参数求值顺序是unspecified

**包含这种行为的程序，重新编译后可能得到不同的结果**

### 实现定义行为

一类特殊的未指定行为，具体实现需要将选择写到文档里

- 写进文档之后就不能随便改了
- 若专门为某特定系统开发程序，开发者可以假设这些选择成立

例：变量类型的大小

**包含这种行为的程序，在相同的环境下运行可以得到相同的结果**

- **但在移植到另一个环境时可能会出现问题**

### 未定义行为

程序/数据不符合标准的行为

完全没说会发生什么，一切皆有可能

例：内存溢出

**包含这种行为的程序，多次运行可能也无法得到正确的结果**

### 实现定义行为的选择写到了哪个文档里？

编译器+处理器+操作系统+运行时库，这几者需要达成一致的约定

这就是`ABI`，具体包含

- 处理器指令集，寄存器结构，栈的组织，访存类型等
- 处理器可直接访问的基本数据类型的大小，布局，对齐方式
- 调用约定，对于规定函数的参数如何传递，返回值如何获取
- 应用程序如何向操作系统发起调用
- 目标文件的格式，支持的运行时库等

ABI手册是计算机系统软硬件协同的重要体现

### 如何使用跨平台固定长度的数据类型？

#include<stdint.h>

可以使用uint8_t等类型 运行时库会帮我们定义成正确的类型

### 程序输出什么?

最好不要用char	用signed char或unsigned char